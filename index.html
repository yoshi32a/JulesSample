<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–æ•°å­¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            flex-direction: column;
            touch-action: none;
            overflow: hidden;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
        }

        h1 {
            color: #333;
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 8px;
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            background: #667eea;
            color: white;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s;
            touch-action: manipulation;
        }

        .mode-btn:active {
            transform: scale(0.95);
        }

        .mode-btn.active {
            background: #764ba2;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
        }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            min-height: 0;
            overflow: hidden;
        }

        canvas {
            background: white;
            border-radius: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            max-width: 100%;
            max-height: 100%;
            touch-action: none;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            max-height: 50vh;
            overflow-y: auto;
            flex-shrink: 0;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            color: #333;
            font-size: 0.9rem;
        }

        .control-value {
            font-weight: bold;
            color: #667eea;
        }

        input[type="range"] {
            width: 100%;
            height: 40px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-track {
            height: 8px;
            background: #ddd;
            border-radius: 4px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -8px;
        }

        input[type="range"]::-moz-range-track {
            height: 8px;
            background: #ddd;
            border-radius: 4px;
        }

        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .info {
            text-align: center;
            color: #666;
            font-size: 0.8rem;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
        }

        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            color: #333;
            font-size: 1rem;
            cursor: pointer;
            margin-bottom: 15px;
            touch-action: manipulation;
        }

        .formula-display {
            text-align: center;
            font-size: 1.2rem;
            color: #667eea;
            font-weight: bold;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ”¬ ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–æ•°å­¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼</h1>
        <div class="mode-selector">
            <button class="mode-btn active" data-mode="projectile">å¼¾é“è¨ˆç®—</button>
            <button class="mode-btn" data-mode="wave">æ³¢å½¢</button>
            <button class="mode-btn" data-mode="shapes">å›³å½¢</button>
            <button class="mode-btn" data-mode="pendulum">æŒ¯ã‚Šå­</button>
            <button class="mode-btn" data-mode="formula">æ•°å¼</button>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <div class="controls" id="controls">
        <!-- Controls will be dynamically inserted here -->
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const controlsContainer = document.getElementById('controls');

        // Canvas setup
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(container.clientWidth - 20, 800);
            const maxHeight = Math.min(container.clientHeight - 20, 600);
            canvas.width = maxWidth;
            canvas.height = maxHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Current mode and parameters
        let currentMode = 'projectile';
        let params = {};
        let animationId = null;

        // Mode configurations
        const modes = {
            projectile: {
                name: 'å¼¾é“è¨ˆç®—',
                params: {
                    velocity: { label: 'åˆé€Ÿåº¦', min: 10, max: 100, value: 50, unit: 'm/s' },
                    angle: { label: 'è§’åº¦', min: 0, max: 90, value: 45, unit: 'Â°' },
                    gravity: { label: 'é‡åŠ›', min: 5, max: 20, value: 9.8, unit: 'm/sÂ²', step: 0.1 }
                }
            },
            wave: {
                name: 'æ³¢å½¢',
                params: {
                    frequency: { label: 'å‘¨æ³¢æ•°', min: 1, max: 10, value: 2, unit: 'Hz', step: 0.1 },
                    amplitude: { label: 'æŒ¯å¹…', min: 10, max: 100, value: 50, unit: 'px' },
                    phase: { label: 'ä½ç›¸', min: 0, max: 360, value: 0, unit: 'Â°' }
                }
            },
            shapes: {
                name: 'å›³å½¢',
                params: {
                    sides: { label: 'è¾ºã®æ•°', min: 3, max: 12, value: 6, unit: 'è¾º' },
                    radius: { label: 'åŠå¾„', min: 50, max: 200, value: 100, unit: 'px' },
                    rotation: { label: 'å›è»¢', min: 0, max: 360, value: 0, unit: 'Â°' }
                }
            },
            pendulum: {
                name: 'æŒ¯ã‚Šå­',
                params: {
                    length: { label: 'é•·ã•', min: 50, max: 250, value: 150, unit: 'px' },
                    angle: { label: 'åˆæœŸè§’åº¦', min: -80, max: 80, value: 45, unit: 'Â°' },
                    damping: { label: 'æ¸›è¡°ç‡', min: 0, max: 1, value: 0.995, unit: '', step: 0.001 }
                }
            },
            formula: {
                name: 'æ•°å¼',
                params: {
                    a: { label: 'ä¿‚æ•° a', min: -5, max: 5, value: 1, unit: '', step: 0.1 },
                    b: { label: 'ä¿‚æ•° b', min: -5, max: 5, value: 0, unit: '', step: 0.1 },
                    c: { label: 'ä¿‚æ•° c', min: -10, max: 10, value: 0, unit: '', step: 0.1 },
                    zoom: { label: 'æ‹¡å¤§ç‡', min: 1, max: 50, value: 20, unit: 'x' }
                }
            }
        };

        // Current formula type
        let currentFormula = 'quadratic';

        // Initialize controls
        function initControls() {
            const mode = modes[currentMode];
            params = {};

            let html = '';

            // Add formula selector for formula mode
            if (currentMode === 'formula') {
                html += `
                    <select id="formula-selector">
                        <option value="quadratic">äºŒæ¬¡é–¢æ•°: y = axÂ² + bx + c</option>
                        <option value="cubic">ä¸‰æ¬¡é–¢æ•°: y = axÂ³ + bxÂ² + c</option>
                        <option value="sin">æ­£å¼¦é–¢æ•°: y = aÂ·sin(bx) + c</option>
                        <option value="cos">ä½™å¼¦é–¢æ•°: y = aÂ·cos(bx) + c</option>
                        <option value="tan">æ­£æ¥é–¢æ•°: y = aÂ·tan(bx) + c</option>
                        <option value="exp">æŒ‡æ•°é–¢æ•°: y = aÂ·e^(bx) + c</option>
                        <option value="log">å¯¾æ•°é–¢æ•°: y = aÂ·ln(bx) + c</option>
                        <option value="abs">çµ¶å¯¾å€¤: y = aÂ·|bx| + c</option>
                        <option value="inverse">åæ¯”ä¾‹: y = a/x + c</option>
                        <option value="sqrt">å¹³æ–¹æ ¹: y = aÂ·âˆš(bx) + c</option>
                    </select>
                    <div class="formula-display" id="formula-display">y = axÂ² + bx + c</div>
                `;
            }

            for (const [key, config] of Object.entries(mode.params)) {
                params[key] = config.value;
                const step = config.step || 1;
                html += `
                    <div class="control-group">
                        <div class="control-label">
                            <span>${config.label}</span>
                            <span class="control-value" id="${key}-value">${config.value}${config.unit}</span>
                        </div>
                        <input type="range" id="${key}" min="${config.min}" max="${config.max}"
                               value="${config.value}" step="${step}" data-unit="${config.unit}">
                    </div>
                `;
            }

            html += '<div class="info">ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’èª¿æ•´ã—ã¦ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¦³å¯Ÿã—ã¾ã—ã‚‡ã†</div>';
            controlsContainer.innerHTML = html;

            // Add formula selector event listener
            if (currentMode === 'formula') {
                const formulaSelector = document.getElementById('formula-selector');
                formulaSelector.addEventListener('change', (e) => {
                    currentFormula = e.target.value;
                    updateFormulaDisplay();
                });
            }

            // Add event listeners
            for (const key of Object.keys(mode.params)) {
                const input = document.getElementById(key);
                const valueDisplay = document.getElementById(`${key}-value`);
                const unit = input.dataset.unit;

                input.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    params[key] = value;
                    valueDisplay.textContent = `${value}${unit}`;
                });

                // Touch support
                input.addEventListener('touchstart', (e) => {
                    e.target.focus();
                });
            }
        }

        // Update formula display
        function updateFormulaDisplay() {
            const formulaDisplay = document.getElementById('formula-display');
            if (!formulaDisplay) return;

            const formulas = {
                quadratic: 'y = axÂ² + bx + c',
                cubic: 'y = axÂ³ + bxÂ² + c',
                sin: 'y = aÂ·sin(bx) + c',
                cos: 'y = aÂ·cos(bx) + c',
                tan: 'y = aÂ·tan(bx) + c',
                exp: 'y = aÂ·e^(bx) + c',
                log: 'y = aÂ·ln(bx) + c',
                abs: 'y = aÂ·|bx| + c',
                inverse: 'y = a/x + c',
                sqrt: 'y = aÂ·âˆš(bx) + c'
            };

            formulaDisplay.textContent = formulas[currentFormula];
        }

        // Animation functions for each mode
        const animations = {
            projectile: function() {
                let t = 0;
                const dt = 0.016;

                function animate() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    const v0 = params.velocity;
                    const angle = params.angle * Math.PI / 180;
                    const g = params.gravity;

                    const vx = v0 * Math.cos(angle);
                    const vy = v0 * Math.sin(angle);

                    const scale = canvas.width / 200;
                    const x = vx * t * scale * 2;
                    const y = canvas.height - 50 - (vy * t - 0.5 * g * t * t) * scale * 2;

                    // Draw ground
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, canvas.height - 50);
                    ctx.lineTo(canvas.width, canvas.height - 50);
                    ctx.stroke();

                    // Draw trajectory
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i <= t; i += 0.1) {
                        const tx = vx * i * scale * 2;
                        const ty = canvas.height - 50 - (vy * i - 0.5 * g * i * i) * scale * 2;
                        if (i === 0) ctx.moveTo(tx, ty);
                        else ctx.lineTo(tx, ty);
                    }
                    ctx.stroke();

                    // Draw projectile
                    if (y <= canvas.height - 50 && x <= canvas.width) {
                        ctx.fillStyle = '#764ba2';
                        ctx.beginPath();
                        ctx.arc(x, y, 10, 0, Math.PI * 2);
                        ctx.fill();

                        t += dt;
                    } else {
                        t = 0;
                    }

                    animationId = requestAnimationFrame(animate);
                }
                animate();
            },

            wave: function() {
                let time = 0;

                function animate() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    const freq = params.frequency;
                    const amp = params.amplitude;
                    const phase = params.phase * Math.PI / 180;

                    const centerY = canvas.height / 2;

                    // Draw center line
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, centerY);
                    ctx.lineTo(canvas.width, centerY);
                    ctx.stroke();

                    // Draw wave
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 3;
                    ctx.beginPath();

                    for (let x = 0; x < canvas.width; x++) {
                        const y = centerY + amp * Math.sin(freq * x * 0.02 + time + phase);
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();

                    // Draw moving point
                    const pointX = canvas.width / 4;
                    const pointY = centerY + amp * Math.sin(freq * pointX * 0.02 + time + phase);
                    ctx.fillStyle = '#764ba2';
                    ctx.beginPath();
                    ctx.arc(pointX, pointY, 8, 0, Math.PI * 2);
                    ctx.fill();

                    time += 0.05;
                    animationId = requestAnimationFrame(animate);
                }
                animate();
            },

            shapes: function() {
                let rotation = 0;

                function animate() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    const sides = Math.round(params.sides);
                    const radius = params.radius;
                    const baseRotation = params.rotation * Math.PI / 180;

                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;

                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(rotation + baseRotation);

                    // Draw polygon
                    ctx.fillStyle = 'rgba(102, 126, 234, 0.3)';
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 3;
                    ctx.beginPath();

                    for (let i = 0; i <= sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const x = radius * Math.cos(angle);
                        const y = radius * Math.sin(angle);
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Draw center point
                    ctx.fillStyle = '#764ba2';
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw vertices
                    for (let i = 0; i < sides; i++) {
                        const angle = (i / sides) * Math.PI * 2;
                        const x = radius * Math.cos(angle);
                        const y = radius * Math.sin(angle);
                        ctx.fillStyle = '#764ba2';
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();

                    rotation += 0.01;
                    animationId = requestAnimationFrame(animate);
                }
                animate();
            },

            pendulum: function() {
                let angle = params.angle * Math.PI / 180;
                let angularVelocity = 0;

                function animate() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    const length = params.length;
                    const damping = params.damping;

                    const centerX = canvas.width / 2;
                    const centerY = 50;

                    // Physics
                    const angularAcceleration = -0.01 * Math.sin(angle);
                    angularVelocity += angularAcceleration;
                    angularVelocity *= damping;
                    angle += angularVelocity;

                    const bobX = centerX + length * Math.sin(angle);
                    const bobY = centerY + length * Math.cos(angle);

                    // Draw pivot
                    ctx.fillStyle = '#333';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw string
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(bobX, bobY);
                    ctx.stroke();

                    // Draw bob
                    ctx.fillStyle = '#764ba2';
                    ctx.beginPath();
                    ctx.arc(bobX, bobY, 20, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw arc guide
                    ctx.strokeStyle = 'rgba(102, 126, 234, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, length, 0, Math.PI);
                    ctx.stroke();

                    animationId = requestAnimationFrame(animate);
                }
                animate();
            },

            formula: function() {
                function animate() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    const a = params.a;
                    const b = params.b;
                    const c = params.c;
                    const zoom = params.zoom;

                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;

                    // Draw grid
                    ctx.strokeStyle = '#f0f0f0';
                    ctx.lineWidth = 1;

                    // Vertical grid lines
                    for (let x = centerX % 20; x < canvas.width; x += 20) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }

                    // Horizontal grid lines
                    for (let y = centerY % 20; y < canvas.height; y += 20) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }

                    // Draw axes
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;

                    // X-axis
                    ctx.beginPath();
                    ctx.moveTo(0, centerY);
                    ctx.lineTo(canvas.width, centerY);
                    ctx.stroke();

                    // Y-axis
                    ctx.beginPath();
                    ctx.moveTo(centerX, 0);
                    ctx.lineTo(centerX, canvas.height);
                    ctx.stroke();

                    // Draw axis labels
                    ctx.fillStyle = '#666';
                    ctx.font = '12px sans-serif';
                    ctx.fillText('0', centerX + 5, centerY - 5);
                    ctx.fillText('x', canvas.width - 20, centerY - 10);
                    ctx.fillText('y', centerX + 10, 20);

                    // Calculate y value based on formula
                    function calculateY(x) {
                        try {
                            switch(currentFormula) {
                                case 'quadratic':
                                    return a * x * x + b * x + c;
                                case 'cubic':
                                    return a * x * x * x + b * x * x + c;
                                case 'sin':
                                    return a * Math.sin(b * x) + c;
                                case 'cos':
                                    return a * Math.cos(b * x) + c;
                                case 'tan':
                                    return a * Math.tan(b * x) + c;
                                case 'exp':
                                    return a * Math.exp(b * x) + c;
                                case 'log':
                                    return b * x > 0 ? a * Math.log(b * x) + c : NaN;
                                case 'abs':
                                    return a * Math.abs(b * x) + c;
                                case 'inverse':
                                    return x !== 0 ? a / x + c : NaN;
                                case 'sqrt':
                                    return b * x >= 0 ? a * Math.sqrt(b * x) + c : NaN;
                                default:
                                    return 0;
                            }
                        } catch (e) {
                            return NaN;
                        }
                    }

                    // Draw function curve
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 3;
                    ctx.beginPath();

                    let started = false;
                    for (let px = 0; px < canvas.width; px++) {
                        const x = (px - centerX) / zoom;
                        const y = calculateY(x);

                        if (!isNaN(y) && isFinite(y)) {
                            const py = centerY - y * zoom;

                            if (py >= -50 && py <= canvas.height + 50) {
                                if (!started) {
                                    ctx.moveTo(px, py);
                                    started = true;
                                } else {
                                    ctx.lineTo(px, py);
                                }
                            } else {
                                started = false;
                            }
                        } else {
                            started = false;
                        }
                    }
                    ctx.stroke();

                    // Draw point at x=0
                    const y0 = calculateY(0);
                    if (!isNaN(y0) && isFinite(y0)) {
                        const py0 = centerY - y0 * zoom;
                        if (py0 >= 0 && py0 <= canvas.height) {
                            ctx.fillStyle = '#764ba2';
                            ctx.beginPath();
                            ctx.arc(centerX, py0, 6, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    animationId = requestAnimationFrame(animate);
                }
                animate();
            }
        };

        // Mode switching
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.dataset.mode;

                if (animationId) {
                    cancelAnimationFrame(animationId);
                }

                initControls();
                animations[currentMode]();
            });
        });

        // Initialize
        initControls();
        animations[currentMode]();
    </script>
</body>
</html>
